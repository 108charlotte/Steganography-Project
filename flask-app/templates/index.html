<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="{{ url_for ('static', filename='styles.css') }}">
    <!--google fonts import-->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=Kedebideri:wght@400;500;600;700;800;900&family=Roboto+Condensed:ital,wght@0,100..900;1,100..900&family=Share+Tech+Mono&family=Space+Grotesk:wght@300..700&family=Titillium+Web:ital,wght@0,200;0,300;0,400;0,600;0,700;0,900;1,200;1,300;1,400;1,600;1,700&display=swap" rel="stylesheet">
    <title>Steganography Project</title>
  </head>
  <body>
    <h1>Steganography Project</h1>
    <p id="error">{{ error }}</p>
    <form action="/run_stego" method="POST">
        <label for="image_dropdown">Choose an image: </label>
        <select name="image_dropdown" id="image_dropdown">
            <option value="" disabled {% if not selection %}selected{% endif %}></option>
            {% for image_name in image_names %}
                <option value="{{ image_name }}" {% if selection and selection[0]==image_name %}selected{% endif %}>{{ image_name }}</option>
            {% endfor %}
        </select>
        <br>
        <label for="what_to_hide">Choose the information you would like to hide: </label>
        <select name="info_dropdown" id="info_dropdown">
            <option value="" disabled {% if not selection %}selected{% endif %}></option>
            {% for info_name in info_names %}
                <option value="{{ info_name }}" {% if selection and selection[2]==info_name %}selected{% endif %}>{{ info_name }}</option>
            {% endfor %}
        </select>
        <br>
        <label for="stego_dropdown">Choose a method: </label>
        <select name="stego_dropdown" id="stego_dropdown">
            <!--used copilot assistance to assign dropdown values if already passed via flask backend-->
            <option value="" disabled {% if not selection %}selected{% endif %}></option>
            {% for method_name in method_names %}
                <option value="{{ method_name }}" {% if selection and selection[1]==method_name %}selected{% endif %}>{{ method_name }}</option>
            {% endfor %}
        </select>
        <br>
        <button type="submit">Submit</button>
    </form>
    <div id="images">
        <div class="image">
        <h2>Original: </h2>
        <img id="image_slot" width="400px">
        </div>
        <div class="image">
            <h2>Final:</h2>
            <!-- copilot to fix placeholder image not displaying for final: always include the final image element so JS can update it before/after navigation -->
            <img id="final" width="400" src="{% if output_image %}{{ output_image }}{% else %}/static/images/placeholder_img.png{% endif %}">
        </div>
    </div>

    <form action="/decrypt_stego" method="POST" id="decrypt_form">
        <!--used copilot help to silently pass data to backend for decryption-->
        <input type="hidden" name="selected_image" id="decrypt_image_input" value="{% if selection %}{{ selection[0] }}{% endif %}">
        <input type="hidden" name="selected_stego" id="decrypt_method_input" value="{% if selection %}{{ selection[1] }}{% endif %}">
        <input type="hidden" name="selected_info" id="decrypt_info_input" value="{% if selection %}{{ selection[2] }}{% endif %}">
        <button type="submit">Decrypt</button>
    </form>
    <h2>Encrypted/Decrypted Text:</h2>
    <pre id="stego_text" style="white-space: pre-wrap; background:#f6f6f6; padding:10px; border:1px solid #ddd; max-height:300px; overflow:auto;"></pre>
    <script>
        const image_dropdown = document.getElementById('image_dropdown')
        const image_slot = document.getElementById('image_slot')
        const generated_img = document.getElementById('final')

        function set_images_to_selected(selected_img) {
            switch (selected_img) {
                case "trees":
                    image_slot.src = "/static/images/placeholder_img.png"
                    generated_img.src = "/static/images/stego_trees.png"
                    break
                case "sky":
                    image_slot.src = "/static/images/sky.jpg"
                    generated_img.src = "/static/images/stego_sky.png"
                    break
                case "city":
                    image_slot.src = "/static/images/placeholder_img.png"
                    generated_img.src = "/static/images/stego_city.png"
                    break
                case "low saturation":
                    image_slot.src = "/static/images/placeholder_img.png"
                    generated_img.src = "/static/images/stego_low_sat.png"
                    break
                case "high saturation":
                    image_slot.src = "/static/images/placeholder_img.png"
                    generated_img.src = "/static/images/stego_high_sat.png"
                    break
                default:
                    image_slot.src = "/static/images/placeholder_img.png"
                    generated_img.src = "/static/images/placeholder_img.png"
                    break
            }
        }

        let selected_image = "placeholder"
        document.addEventListener('DOMContentLoaded', function () {
            const initial = image_dropdown.value || selected_image
            set_images_to_selected(initial)

            image_dropdown.addEventListener('change', function (e) {
                set_images_to_selected(e.target.value)
            })
            const info_dropdown = document.getElementById("info_dropdown")
            // copilot help: keep decrypt form inputs in sync with current selections
            const decryptImageInput = document.getElementById('decrypt_image_input')
            const decryptMethodInput = document.getElementById('decrypt_method_input')
            const decryptInfoInput = document.getElementById('decrypt_info_input')
            const stegoDropdown = document.getElementById('stego_dropdown')
            if (decryptImageInput) decryptImageInput.value = image_dropdown.value || ''
            if (decryptMethodInput) decryptMethodInput.value = stegoDropdown ? stegoDropdown.value || '' : ''
            if (decryptInfoInput) decryptInfoInput.value = info_dropdown.value || ''
            if (stegoDropdown) {
                stegoDropdown.addEventListener('change', function (e) {
                    if (decryptMethodInput) decryptMethodInput.value = e.target.value
                })
            }

            // coplit generated: --- Stego text polling/display ---
            const stegoTextEl = document.getElementById('stego_text')
            // read selection from the hidden decrypt input (keeps server/template logic centralized)
            const currentInfo = (document.getElementById('decrypt_info_input') && document.getElementById('decrypt_info_input').value) || ''

            function stegoTextPath(infoName) {
                if (!infoName) return ''
                // file saved as '<infoName> Stego.txt' under /static/texts
                return '/static/texts/' + encodeURIComponent(infoName + ' Stego.txt')
            }

            let pollTimer = null
            let lastLength = -1
            let stableCount = 0

            function startPollingForInfo(infoName) {
                if (!infoName) return
                stopPolling()
                lastLength = -1
                stableCount = 0
                const url = stegoTextPath(infoName)
                const maxDuration = 30000 // stop after 30s
                const interval = 1000
                const startAt = Date.now()

                pollTimer = setInterval(async () => {
                    try {
                        const resp = await fetch(url, { cache: 'no-store' })
                        if (!resp.ok) {
                            // file not yet created, show placeholder
                            stegoTextEl.textContent = ''
                        } else {
                            const text = await resp.text()
                            stegoTextEl.textContent = text
                            if (text.length === lastLength) {
                                stableCount += 1
                            } else {
                                stableCount = 0
                                lastLength = text.length
                            }
                            // if unchanged for 3 polls, assume write finished and stop polling
                            if (stableCount >= 3) {
                                stopPolling()
                            }
                        }
                    } catch (e) {
                        // ignore network errors while file is being created
                    }
                    if (Date.now() - startAt > maxDuration) stopPolling()
                }, interval)
            }

            function stopPolling() {
                if (pollTimer) {
                    clearInterval(pollTimer)
                    pollTimer = null
                }
            }

            // start polling if a selection was already present when the page was rendered
            if (currentInfo) startPollingForInfo(currentInfo)

            // --- Final image polling/display ---
            const finalImg = document.getElementById('final')
            const decryptImageInputEl = document.getElementById('decrypt_image_input')

            function expectedFinalPathFor(name) {
                if (!name) return ''
                switch (name) {
                    case 'trees': return '/static/images/stego_trees.png'
                    case 'sky': return '/static/images/stego_sky.png'
                    case 'city': return '/static/images/stego_city.png'
                    case 'low saturation': return '/static/images/stego_low_saturation.png'
                    case 'high saturation': return '/static/images/stego_high_saturation.png'
                    default: return '/static/images/placeholder_img.png'
                }
            }

            // try to load an image URL; resolves true on load, false on error
            function loadImage(url, timeout = 5000) {
                return new Promise((resolve) => {
                    const img = new Image()
                    let finished = false
                    img.onload = () => { if (!finished) { finished = true; resolve(true) } }
                    img.onerror = () => { if (!finished) { finished = true; resolve(false) } }
                    img.src = url + (url.includes('?') ? '&' : '?') + 't=' + Date.now()
                    setTimeout(() => { if (!finished) { finished = true; resolve(false) } }, timeout)
                })
            }

            let imagePollTimer = null
            function startPollingForFinal(name) {
                if (!name) return
                stopPollingForFinal()
                const url = expectedFinalPathFor(name)
                const interval = 1000
                const maxTime = 30000
                const start = Date.now()
                imagePollTimer = setInterval(async () => {
                    const ok = await loadImage(url, 800)
                    if (ok) {
                        finalImg.src = url
                        stopPollingForFinal()
                        return
                    }
                    if (Date.now() - start > maxTime) stopPollingForFinal()
                }, interval)
            }

            function stopPollingForFinal() {
                if (imagePollTimer) { clearInterval(imagePollTimer); imagePollTimer = null }
            }

            // If a selection exists on load, attempt to show the final image when it's ready
            const selectedOnLoad = decryptImageInputEl ? decryptImageInputEl.value : (image_dropdown.value || '')
            if (selectedOnLoad) {
                // if template provided a real output_image it will already be shown; otherwise poll
                const expected = expectedFinalPathFor(selectedOnLoad)
                if (!({% if output_image %}true{% else %}false{% endif %})) {
                    // no output_image provided by server; poll for generated image
                    startPollingForFinal(selectedOnLoad)
                } else {
                    // server provided an output_image; still start polling to replace placeholder when created
                    startPollingForFinal(selectedOnLoad)
                }
            }

            // when the run form is submitted, immediately show placeholder on the final image
            const runForm = document.querySelector('form[action="/run_stego"]')
            if (runForm) {
                runForm.addEventListener('submit', function () {
                    // show placeholder while server works
                    if (finalImg) finalImg.src = '/static/images/placeholder_img.png'
                    // after submission the page will reload; the new page will poll for the final image
                })
            }

            // also start polling when decrypt form is submitted
            const decryptForm = document.getElementById('decrypt_form')
            if (decryptForm) {
                decryptForm.addEventListener('submit', function () {
                    const infoName = document.getElementById('decrypt_info_input').value || ''
                    if (infoName) {
                        // small delay to allow server to create the file
                        setTimeout(() => startPollingForInfo(infoName), 250)
                    }
                })
            }
        })
    </script>
  </body>
</html>